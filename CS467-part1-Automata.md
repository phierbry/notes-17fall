# CS467 part1 Automata
##log 
**week2** lec2pdf-22, note-22, book-none
## Total story

### Lec-1
One of the simplest models for procedure is Finite Automata. There are two kind of automatas. DFA and NFA.We give the definition of DFA and NFA. We prove that they are **equivalent** and give the algorithm of conversion. From DFA and NFA which is co-called **machine**, we have can define **a language is regular**. This is from machine's point of view. Then we turn to **syntactic**. We introduce **regular expression**. Language is a set, regular expression is an expression. We have the same **operations** on expression, machine and set. Then we prove that regular expression and FA is **equivalent**. It seems that FA and regular expression can model many language. But we can't use it to model language involved counting. So we have **pumping lemma**, a property that regular language have. We often use pumping lemma to prove the language is not a regular language. Finally, we consider **three problems** of regular language, acceptance, emptiness, equality. It's easy to find the intuition solution from DFA.

**Homework 1:**
how to simplify the DFA to the simplest
Regular expression -> NFA -> DFA is a bad idea. Good idea is state definition -> DFA !


### Finite Automata definiton
> We will see that the most important thing of finite automata is that $Q$ is **finite**

**Two kinds:** deterministic finite automata(DFA) and non-dfa(NFA)

**DFA definiton** 5-tuple $(Q, \Sigma, \delta, q_0, F)$
- $Q$: states, a finite set
- $\Sigma$: alphabet, a finite set 
- $\delta:Q \times \Sigma \leftarrow Q$: transitoin function 
- $q_0 \in Q$: start state, **only one**
- $F \subseteq Q$: accept states set 
**DFA computation: how to use DFA, accept, recognize** 
$M=(Q, \Sigma, \delta, q_0, F)$ is a DFA, $w=w_1w_2...w_n$ is a string generated by alphabet $\Sigma$. We define $M$ **accepts** $w$ if there exists a sequence of states $r_0, r_1, ..., r_n$ in $Q$ such that:
- $r_0=q_0$
- $r_i=\delta(r_{i-1},w_i)$ for $i=1,...,n$
- $r_n \in F$
For a set $A$, $M$ **recognize** $A$ if $A=\\{ \mathcal{l}|M \  accept \ \mathcal{l} \\}$

**NFA definition** also 5-tuple $(Q, \Sigma, \delta, q_0, F)$
- $\delta: Q \times \Sigma_\epsilon \leftarrow \mathcal{P}(Q)$, where $\Sigma_\epsilon = \Sigma \cup {\epsilon}$
- ps. use power set is quite precise, many ways or no way.
**NFA computation: some differences**
- len(string) != len(states): $w=y_1y_2...y_m$
- alphabet is $\Sigma_{\epsilon}: y_i \in \Sigma_{\epsilon}$
- transition: $ r_i \in \delta(r_{i-1}, y_i) $

### Equivalence of NFAs and DFAs
*Remark: The basic problem in cs is **np?p**. It's about non-determinism and determinisim. Here we show that in automata, they are the same! We can leave out the non-determinism!*
>Theorem
Every NFA has an equivlent DFA, i.e., they recognize the same language.

**proof main idea:** to leave out the non-determinism, we view a set of states in NFA as a new single state in DFA. This cause many states in DFA ($\mathcal{P}(Q)$).
**proof:** Two steps
**Step1:** we organize some set of states to leave out the influence of $\epsilon$. Define **silently reachable class** $E(q), \forall q \in Q$. 
>**initially** set $E(q)={q}$
**repeat**
	$\forall x \in E(q)$, **if** $\exists y \in \delta(x, \epsilon) \wedge y \notin E(q)$, $E(q)=E(q) \cup {y}$
**util** $E(q)=E'(q)$

**Step2:** define the tuple using $E(q)$. 
> NFA $N=(Q, \Sigma, \delta, q_0, F)$, DFA $D=(Q', \Sigma , \delta', q_0', F')$. 
$q_0'=E(q_0)$   
$Q'=\mathcal{P}(Q)$  
$\delta '$: $\forall R \in Q',\forall a in \Sigma, \delta '(R, a)=\bigcup {E(q)|q \in Q \wedge \exists r \in R (q \in \delta(r,a))}$   
$F'=\\{R \in Q' | R \cap F \neq \emptyset\\}$ 


### Regular languages 
**Definiton:** A language is called *regular* if some finite automata recognizes it.
**As language is a set, we have some operations on set!**
**Regular operators:**
- Union: $A \cup B=\\{ x|x \in A \vee x \in B \\}$
- Concatenationï¼š$A \circ B = \\{xy|x \in A \wedge y \in B \\}$, ($\circ$ sometimes amitted)
- Kleene star: $A^\star=\\{ x_1x_2...x_k | k>=0 \wedge x_i \in A \\}$
**Closure under the regular operator**
> Theorem 
The class of regular languages is closed under the $\cup, \circ, \star $

**proof idea:** regular <=> DFA <=> NFA. We can construct NFA for these regular language. Draw pictures for intuition.
**proof:** $N_1=(Q_1, \Sigma_1, \delta_1, q_1, F_1), N_2=(Q_2, \Sigma_2, \delta_2, q_2, F_2)$
- Union: a new start $q_0$. $\delta(q_0, \epsilon)={q_1, q_2}, \delta(q_0, other)=\emptyset$
- Concatenation: add path form $F_1$ to $q_2$. 
- Kleene star: add $q_0$ to be new start and also a accept state. $\delta(q,\epsilon)=\delta_1(q,\epsilon)\cup\\{q_0\\}, q \in F_1$, $\delta(q_0, \epsilon)=\\{q_1\\}$

**Other closure property**
- **Complement** $\bar{A}=\Sigma^\star-A$
- **Intersection** $A \cap B$
> Theorem
These two are also close.
**proof for complement:** $\bar{A}=DFA(Q,\Sigma, \delta, q_0, Q-F)$ 
**ps** must use DFA, consider a NFA that $q_0$ and some $F$ forms a loop with two $\epsilon$ edge
**proof for intersection:** 1. De Morgan $A \cap B=\overline{\overline{A} \cap \overline{B}}$

### Regular language and regular expression
Left is regular expression, right is language
Three basic elements: $a, \epsilon, \emptyset$, $\{a\}, \{ \epsilon \}, \emptyset $
Three basic operations:  $(R_1 \cup R_2), (R_1 \circ R_2), (R_1 \star R_2)$, $L(R_1)\cup L(R_2), L(R_1) \circ L(R_2), L(R_1) \star L(R_2)$

**Equivalence of regular language and regular expression**
> Theorem 
A language is regular if and only if some regular expression describes it.
Proof: 
**if (<=):** regular expression can be easily described by FA (routine)
**only if(=>):** use DP-like idea 
define $R(i,j,k)$, language(a string set) that start from *state $i$*, end at *state $j$*, the *largest passby state $k$*.
set can be operated: $R(i,j,k)=R(i,j,k-1) \cup R(i,k,k-1) \circ R(k,k,k-1) ^ \star \circ R(k,j,k-1)$
Then the desired regular expression: $L(M)=\bigcup{R(1,j,n)\ \forall j}$
this formula will reach a final state, because $k$ decrese $1$ every time, and the final state is simple enough to form regular expression directly, we only need to inverse the operations.

### Limitation of regular language
Consider language involved conuting $\\{ \mathcal{l} | \mathcal{l} \  has \  equal \  number \  of \  0 \ and \ 1\\}$
We cannot write a regular expression for it. But how to prove it?

**Pumping lemma for regular language**
> Theorem
If $A$ is a regular language, then there is a number $p$(the pumping length) where if $s$ is any string in $A$ of length at least $p$, then $s$ may be divided into three pieces, $s=xyz$, satisfying the following conditions:
1. $|y|>0$
2. $|xy| \leq p$
3. for each $i \geq 0, xy^iz \in A$ ($y$ can be pumped)
proof: 
DFA $M=(Q,\Sigma,\delta,q, F)$ recognize $A$ and $p=|Q|$. Let $s=s_1s_2...s_n$ be a string in $A$ with $n \geq p$. Let $r_1, r_2, ... ,r_n+1$ be the sequence of states that $M$ enters while processing $s$, $r_{i+1}=\delta(r_i, s_i)$ for $i \in [n]$. 
Among the first $p+1$ states in the sequence, two must be the same, say $r_j$ and $r_k$ with $j < k \leq p+1$. Then $x=s_1...s_j-1, y=s_j...s_{k-1}, z=s_k...s_n$. 
The keypoint is pigeonhole principle, there must be repeated states and the repeated states is the source pump!

**Two examples of pumping lemma**
1. The language $L=\\{0^n1^n|n \geq 0\\} is not regular$
2. The language $L=\\{w|w\ has\ an\ equal\ number\ of\ 0s\ and\ 1s\\}$ is not regular.

### Problems from formal language theory
Three Decision Problems 
- Acceptance, Emptiness, Equality
These three problems concerning FA 
> Theorem 
- Acceptance: Given a DFA $A$ and a string $w$, does $A$ accept $w$?
- Emptiness: Given a DFA $A$ is the language $L(A)$ empty?
- Equality: Given two DFA $A$ and $B$ is $L(A)$ equal to $L(B)$?
Then we can see that these three problems are decidable. 





